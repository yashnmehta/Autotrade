#include "app/ScripBar.h"
#include "ui_ScripBar.h"
#include "api/XTSMarketDataClient.h"
#include <QDebug>
#include <QMessageBox>

ScripBar::ScripBar(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::ScripBar)
    , m_xtsClient(nullptr)
    , m_currentStrike(0.0)
{
    ui->setupUi(this);
    setupUI();
}

ScripBar::~ScripBar()
{
    delete ui;
}

void ScripBar::setXTSClient(XTSMarketDataClient *client)
{
    m_xtsClient = client;
    qDebug() << "XTS client set for ScripBar";
}

void ScripBar::setupUI()
{
    // Populate initial data
    populateExchanges();
    
    // Connect signals
    connect(ui->cbExchange, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onExchangeChanged);
    connect(ui->cbSegment, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onSegmentChanged);
    connect(ui->cbInstrument, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onInstrumentChanged);
    connect(ui->cbSymbol, &QComboBox::currentTextChanged,
            this, &ScripBar::onSymbolTextChanged);
    connect(ui->cbSymbol, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onSymbolSelected);
    connect(ui->cbExpiry, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onExpiryChanged);
    connect(ui->cbStrike, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onStrikeChanged);
    connect(ui->cbOptionType, QOverload<int>::of(&QComboBox::currentIndexChanged),
            this, &ScripBar::onOptionTypeChanged);
    connect(ui->btnAddToWatch, &QPushButton::clicked,
            this, &ScripBar::onAddToWatchClicked);
}

void ScripBar::populateExchanges()
{
    ui->cbExchange->clear();
    ui->cbExchange->addItem("NSE");
    ui->cbExchange->addItem("BSE");
    ui->cbExchange->setCurrentIndex(0);
    
    populateSegments();
}

void ScripBar::populateSegments()
{
    ui->cbSegment->clear();
    
    QString exchange = getCurrentExchange();
    
    if (exchange == "NSE") {
        ui->cbSegment->addItem("CM");  // Cash Market
        ui->cbSegment->addItem("FO");  // Futures & Options
        ui->cbSegment->addItem("CD");  // Currency Derivatives
    } else if (exchange == "BSE") {
        ui->cbSegment->addItem("CM");  // Cash Market
        ui->cbSegment->addItem("FO");  // Futures & Options
    }
    
    ui->cbSegment->setCurrentIndex(0);
    populateInstruments();
}

void ScripBar::populateInstruments()
{
    ui->cbInstrument->clear();
    
    QString segment = getCurrentSegment();
    
    if (segment == "CM") {
        ui->cbInstrument->addItem("EQUITY");
    } else if (segment == "FO") {
        ui->cbInstrument->addItem("FUTIDX");   // Index Futures
        ui->cbInstrument->addItem("FUTSTK");   // Stock Futures
        ui->cbInstrument->addItem("OPTIDX");   // Index Options
        ui->cbInstrument->addItem("OPTSTK");   // Stock Options
    } else if (segment == "CD") {
        ui->cbInstrument->addItem("FUTCUR");   // Currency Futures
        ui->cbInstrument->addItem("OPTCUR");   // Currency Options
    }
    
    ui->cbInstrument->setCurrentIndex(0);
    
    // Clear dependent combos
    ui->cbSymbol->clear();
    ui->cbExpiry->clear();
    ui->cbStrike->clear();
    ui->cbOptionType->clear();
}

void ScripBar::searchSymbols(const QString &searchText)
{
    if (!m_xtsClient || searchText.length() < 2) {
        return;
    }
    
    int segmentCode = getCurrentExchangeSegmentCode();
    if (segmentCode == -1) {
        qWarning() << "Invalid exchange segment";
        return;
    }
    
    qDebug() << "Searching for:" << searchText << "in segment:" << segmentCode;
    
    // Call XTS API to search instruments
    m_xtsClient->searchInstruments(searchText, segmentCode,
        [this](bool success, const QVector<XTS::Instrument> &instruments, const QString &error) {
            if (success) {
                qDebug() << "Found" << instruments.size() << "instruments";
                
                // Convert to InstrumentData and cache
                m_instrumentCache.clear();
                for (const auto &inst : instruments) {
                    InstrumentData data;
                    data.exchangeInstrumentID = inst.exchangeInstrumentID;
                    data.name = inst.instrumentName;
                    data.symbol = inst.instrumentName; // Simplification
                    data.exchangeSegment = inst.exchangeSegment;
                    m_instrumentCache.append(data);
                }
                
                // Update symbol combo
                ui->cbSymbol->clear();
                QSet<QString> uniqueSymbols;
                for (const auto &inst : m_instrumentCache) {
                    uniqueSymbols.insert(inst.symbol);
                }
                
                for (const QString &symbol : uniqueSymbols) {
                    ui->cbSymbol->addItem(symbol);
                }
            } else {
                qWarning() << "Search failed:" << error;
            }
        });
}

void ScripBar::populateExpiries()
{
    ui->cbExpiry->clear();
    
    QString symbol = ui->cbSymbol->currentText();
    if (symbol.isEmpty()) return;
    
    // Filter instruments for this symbol
    QSet<QString> expiries;
    for (const auto &inst : m_instrumentCache) {
        if (inst.symbol == symbol && !inst.expiryDate.isEmpty()) {
            expiries.insert(inst.expiryDate);
        }
    }
    
    // Add to combo (sorted)
    QStringList expiryList = expiries.values();
    expiryList.sort();
    ui->cbExpiry->addItems(expiryList);
}

void ScripBar::populateStrikes()
{
    ui->cbStrike->clear();
    
    QString symbol = ui->cbSymbol->currentText();
    QString expiry = ui->cbExpiry->currentText();
    if (symbol.isEmpty() || expiry.isEmpty()) return;
    
    // Filter instruments for this symbol and expiry
    QSet<double> strikes;
    for (const auto &inst : m_instrumentCache) {
        if (inst.symbol == symbol && inst.expiryDate == expiry && inst.strikePrice > 0) {
            strikes.insert(inst.strikePrice);
        }
    }
    
    // Add to combo (sorted numerically)
    QList<double> strikeList = strikes.values();
    std::sort(strikeList.begin(), strikeList.end());
    
    for (double strike : strikeList) {
        ui->cbStrike->addItem(QString::number(strike, 'f', 2));
    }
}

void ScripBar::populateOptionTypes()
{
    ui->cbOptionType->clear();
    
    QString instrument = ui->cbInstrument->currentText();
    if (instrument.contains("OPT")) {
        ui->cbOptionType->addItem("CE");  // Call European
        ui->cbOptionType->addItem("PE");  // Put European
    }
}

QString ScripBar::getCurrentExchange() const
{
    return ui->cbExchange->currentText();
}

QString ScripBar::getCurrentSegment() const
{
    return ui->cbSegment->currentText();
}

int ScripBar::getCurrentExchangeSegmentCode() const
{
    QString exchange = getCurrentExchange();
    QString segment = getCurrentSegment();
    
    // Map to XTS segment codes
    if (exchange == "NSE" && segment == "CM") return 1;   // NSECM
    if (exchange == "NSE" && segment == "FO") return 2;   // NSEFO
    if (exchange == "NSE" && segment == "CD") return 13;  // NSECD
    if (exchange == "BSE" && segment == "CM") return 11;  // BSECM
    if (exchange == "BSE" && segment == "FO") return 12;  // BSEFO
    
    return -1;
}

// Slot implementations
void ScripBar::onExchangeChanged(int index)
{
    qDebug() << "Exchange changed to:" << ui->cbExchange->currentText();
    populateSegments();
}

void ScripBar::onSegmentChanged(int index)
{
    qDebug() << "Segment changed to:" << ui->cbSegment->currentText();
    populateInstruments();
}

void ScripBar::onInstrumentChanged(int index)
{
    qDebug() << "Instrument changed to:" << ui->cbInstrument->currentText();
    
    // Clear dependent combos
    ui->cbSymbol->clear();
    ui->cbExpiry->clear();
    ui->cbStrike->clear();
    
    // Update option type visibility
    populateOptionTypes();
}

void ScripBar::onSymbolTextChanged(const QString &text)
{
    // Trigger search when user types
    if (text.length() >= 2) {
        searchSymbols(text);
    }
}

void ScripBar::onSymbolSelected(int index)
{
    m_currentSymbol = ui->cbSymbol->currentText();
    qDebug() << "Symbol selected:" << m_currentSymbol;
    
    populateExpiries();
}

void ScripBar::onExpiryChanged(int index)
{
    m_currentExpiry = ui->cbExpiry->currentText();
    qDebug() << "Expiry selected:" << m_currentExpiry;
    
    populateStrikes();
}

void ScripBar::onStrikeChanged(int index)
{
    QString strikeText = ui->cbStrike->currentText();
    m_currentStrike = strikeText.toDouble();
    qDebug() << "Strike selected:" << m_currentStrike;
}

void ScripBar::onOptionTypeChanged(int index)
{
    m_currentOptionType = ui->cbOptionType->currentText();
    qDebug() << "Option type selected:" << m_currentOptionType;
}

void ScripBar::onAddToWatchClicked()
{
    QString symbol = ui->cbSymbol->currentText();
    if (symbol.isEmpty()) {
        QMessageBox::warning(this, "No Symbol", "Please select a symbol first");
        return;
    }
    
    // Find the matching instrument
    int64_t token = -1;
    QString fullSymbol = symbol;
    double ltp = 0.0;
    
    QString instrument = ui->cbInstrument->currentText();
    QString expiry = ui->cbExpiry->currentText();
    QString strike = ui->cbStrike->currentText();
    QString optionType = ui->cbOptionType->currentText();
    
    // Build full symbol name
    if (instrument.contains("FUT")) {
        fullSymbol = QString("%1 %2 FUT").arg(symbol, expiry);
    } else if (instrument.contains("OPT")) {
        fullSymbol = QString("%1 %2 %3 %4").arg(symbol, expiry, strike, optionType);
    }
    
    // Find token from cache
    for (const auto &inst : m_instrumentCache) {
        bool match = (inst.symbol == symbol);
        
        if (!expiry.isEmpty() && inst.expiryDate != expiry) continue;
        if (!strike.isEmpty() && inst.strikePrice != strike.toDouble()) continue;
        if (!optionType.isEmpty() && inst.optionType != optionType) continue;
        
        if (match) {
            token = inst.exchangeInstrumentID;
            break;
        }
    }
    
    if (token == -1) {
        QMessageBox::warning(this, "Instrument Not Found", 
                           "Could not find instrument token. Please try searching again.");
        return;
    }
    
    qDebug() << "Adding to watch:" << fullSymbol << "Token:" << token;
    
    emit addToWatchRequested(token, fullSymbol, getCurrentExchange(), ltp);
    
    QMessageBox::information(this, "Added", 
                            QString("Added %1 to market watch").arg(fullSymbol));
}
