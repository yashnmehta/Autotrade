#include "ui/CustomScripComboBox.h"
#include <QKeyEvent>
#include <QAbstractItemView>
#include <QScrollBar>
#include <QStandardItem>
#include <QRegularExpression>
#include <QApplication>
#include <QStyle>
#include <QPainter>
#include <QStyledItemDelegate>
#include <QDebug>
#include <algorithm>

// Debug logging control
#define DEBUG_COMBOBOX 1

#if DEBUG_COMBOBOX
#define COMBO_DEBUG(msg) qDebug() << "[CustomScripComboBox]" << msg
#else
#define COMBO_DEBUG(msg)
#endif

// Custom delegate to highlight matched text
class HighlightDelegate : public QStyledItemDelegate
{
    Q_OBJECT
    
private:
    QString m_filter;
    QColor m_highlightColor;
    
public:
    explicit HighlightDelegate(QObject *parent = nullptr) 
        : QStyledItemDelegate(parent)
        , m_highlightColor("#FFD700")  // Gold color
    {}
    
    void setFilter(const QString &filter) {
        m_filter = filter;
    }
    
    void setHighlightColor(const QColor &color) {
        m_highlightColor = color;
    }
    
    void paint(QPainter *painter, const QStyleOptionViewItem &option, 
               const QModelIndex &index) const override
    {
        QStyleOptionViewItem opt = option;
        initStyleOption(&opt, index);
        
        painter->save();
        
        // Draw background
        if (option.state & QStyle::State_Selected) {
            painter->fillRect(option.rect, option.palette.highlight());
        } else if (option.state & QStyle::State_MouseOver) {
            painter->fillRect(option.rect, QColor("#2d2d30"));
        }
        
        // Get text
        QString text = index.data(Qt::DisplayRole).toString();
        
        // Set text color
        if (option.state & QStyle::State_Selected) {
            painter->setPen(option.palette.highlightedText().color());
        } else {
            painter->setPen(option.palette.text().color());
        }
        
        // Draw text with highlighting
        QRect textRect = option.rect.adjusted(8, 0, -8, 0);
        
        if (!m_filter.isEmpty() && text.contains(m_filter, Qt::CaseInsensitive)) {
            // Find match position
            int pos = text.indexOf(m_filter, 0, Qt::CaseInsensitive);
            
            // Draw text before match
            QString before = text.left(pos);
            QRect beforeRect = textRect;
            painter->drawText(beforeRect, Qt::AlignLeft | Qt::AlignVCenter, before);
            
            // Calculate position for highlighted part
            int beforeWidth = painter->fontMetrics().horizontalAdvance(before);
            QRect highlightRect = textRect.adjusted(beforeWidth, 2, 0, -2);
            
            // Draw highlighted background
            QString matched = text.mid(pos, m_filter.length());
            int matchWidth = painter->fontMetrics().horizontalAdvance(matched);
            highlightRect.setWidth(matchWidth);
            painter->fillRect(highlightRect, m_highlightColor);
            
            // Draw matched text in black
            painter->setPen(Qt::black);
            QFont boldFont = painter->font();
            boldFont.setBold(true);
            painter->setFont(boldFont);
            painter->drawText(highlightRect, Qt::AlignLeft | Qt::AlignVCenter, matched);
            
            // Draw text after match
            painter->setFont(opt.font);
            if (option.state & QStyle::State_Selected) {
                painter->setPen(option.palette.highlightedText().color());
            } else {
                painter->setPen(option.palette.text().color());
            }
            QString after = text.mid(pos + m_filter.length());
            QRect afterRect = textRect.adjusted(beforeWidth + matchWidth, 0, 0, 0);
            painter->drawText(afterRect, Qt::AlignLeft | Qt::AlignVCenter, after);
        } else {
            // No highlighting needed
            painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, text);
        }
        
        painter->restore();
    }
};

CustomScripComboBox::CustomScripComboBox(QWidget *parent)
    : QComboBox(parent)
    , m_sortMode(AlphabeticalSort)
    , m_minCharsForDropdown(0)  // Allow typing freely, dropdown opens immediately
    , m_filterDebounceMs(150)
    , m_highlightColor("#FFD700")  // Gold color for highlighting
    , m_isPopupVisible(false)
    , m_instantFilter(true)  // Default to instant filtering for better UX
{
    COMBO_DEBUG("Constructor called");
    setupUI();
    COMBO_DEBUG("Constructor complete");
}

CustomScripComboBox::~CustomScripComboBox() = default;

void CustomScripComboBox::setupUI()
{
    // Make it editable to get line-edit feel
    setEditable(true);
    setInsertPolicy(QComboBox::NoInsert);
    
    // Get the line edit
    m_lineEdit = lineEdit();
    if (m_lineEdit) {
        m_lineEdit->setClearButtonEnabled(false);  // Disable clear button
        m_lineEdit->setPlaceholderText("Type to search...");
        
        // Install event filter for Tab key handling
        m_lineEdit->installEventFilter(this);
        
        // Connect text editing
        connect(m_lineEdit, &QLineEdit::textEdited, 
                this, &CustomScripComboBox::onTextEdited);
    }
    
    // Setup models
    m_sourceModel = new QStandardItemModel(this);
    m_proxyModel = new QSortFilterProxyModel(this);
    m_proxyModel->setSourceModel(m_sourceModel);
    m_proxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);  // Case-insensitive filtering
    m_proxyModel->setFilterRole(Qt::DisplayRole);
    
    setModel(m_proxyModel);
    
    // Setup list view
    m_listView = qobject_cast<QListView*>(view());
    if (m_listView) {
        m_listView->setUniformItemSizes(true);  // Uniform for performance
        m_listView->setLayoutMode(QListView::Batched);
        
        // Set custom delegate for highlighting
        m_highlightDelegate = new HighlightDelegate(this);
        m_listView->setItemDelegate(static_cast<QStyledItemDelegate*>(m_highlightDelegate));
    }
    
    // Setup filter timer for debouncing
    m_filterTimer = new QTimer(this);
    m_filterTimer->setSingleShot(true);
    connect(m_filterTimer, &QTimer::timeout, 
            this, &CustomScripComboBox::onFilterTimerTimeout);
    
    // Connect item activation
    connect(this, QOverload<int>::of(&QComboBox::activated),
            this, &CustomScripComboBox::onItemActivated);
    
    // Set default max visible items
    setMaxVisibleItems(10);
    
    // Custom styling for better UX
    setStyleSheet(
        "QComboBox {"
        "    border: 1px solid #3f3f46;"
        "    border-radius: 3px;"
        "    padding: 4px 8px;"
        "    background: #1e1e1e;"
        "    color: #ffffff;"
        "    selection-background-color: #094771;"
        "}"
        "QComboBox:focus {"
        "    border: 1px solid #0e639c;"
        "}"
        "QComboBox::drop-down {"
        "    border: none;"
        "    width: 20px;"
        "}"
        "QComboBox::down-arrow {"
        "    width: 0;"
        "    height: 0;"
        "}"
        "QComboBox QAbstractItemView {"
        "    background: #1e1e1e;"
        "    color: #ffffff;"
        "    selection-background-color: #094771;"
        "    selection-color: #ffffff;"
        "    border: 1px solid #3f3f46;"
        "    outline: none;"
        "}"
        "QComboBox QAbstractItemView::item {"
        "    padding: 4px 8px;"
        "    min-height: 20px;"
        "}"
        "QComboBox QAbstractItemView::item:hover {"
        "    background: #2d2d30;"
        "}"
        "QComboBox QAbstractItemView::item:selected {"
        "    background: #094771;"
        "}"
        "QLineEdit {"
        "    border: none;"
        "    background: transparent;"
        "    color: #ffffff;"
        "    selection-background-color: #094771;"
        "}"
    );
}

void CustomScripComboBox::setSortMode(SortMode mode)
{
    m_sortMode = mode;
    sortItems();
}

void CustomScripComboBox::setMinCharsForDropdown(int chars)
{
    m_minCharsForDropdown = qMax(0, chars);
}

void CustomScripComboBox::setFilterDebounceMs(int ms)
{
    m_filterDebounceMs = qMax(0, ms);
}

void CustomScripComboBox::setMaxVisibleItems(int count)
{
    QComboBox::setMaxVisibleItems(count);
}

void CustomScripComboBox::setHighlightColor(const QString &color)
{
    m_highlightColor = color;
}

void CustomScripComboBox::setInstantFilter(bool enabled)
{
    m_instantFilter = enabled;
    COMBO_DEBUG("Instant filter" << (enabled ? "enabled" : "disabled"));
}

void CustomScripComboBox::addItem(const QString &text, const QVariant &userData)
{
    if (text.isEmpty() || m_allItems.contains(text)) {
        COMBO_DEBUG("addItem skipped:" << text << "(empty or duplicate)");
        return;
    }
    
    COMBO_DEBUG("addItem:" << text);
    m_allItems.append(text);
    
    QStandardItem *item = new QStandardItem(text);
    item->setData(userData, Qt::UserRole);
    m_sourceModel->appendRow(item);
    
    sortItems();
}

void CustomScripComboBox::addItems(const QStringList &texts)
{
    COMBO_DEBUG("addItems: count =" << texts.count());
    for (const QString &text : texts) {
        addItem(text);
    }
}

void CustomScripComboBox::clearItems()
{
    COMBO_DEBUG("clearItems called");
    m_allItems.clear();
    m_sourceModel->clear();
    if (m_lineEdit) {
        m_lineEdit->clear();
    }
}

QString CustomScripComboBox::currentText() const
{
    return m_lineEdit ? m_lineEdit->text() : QComboBox::currentText();
}

void CustomScripComboBox::selectAllText()
{
    if (m_lineEdit) {
        m_lineEdit->selectAll();
    }
}

bool CustomScripComboBox::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == m_lineEdit && event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
        
        // Handle Tab key - select all text
        if (keyEvent->key() == Qt::Key_Tab) {
            selectAllText();
            return true; // Event handled
        }
        
        // Handle Shift+Tab
        if (keyEvent->key() == Qt::Key_Backtab) {
            selectAllText();
            return false; // Let it propagate for focus change
        }
    }
    
    return QComboBox::eventFilter(obj, event);
}

void CustomScripComboBox::keyPressEvent(QKeyEvent *event)
{
    switch (event->key()) {
        case Qt::Key_Escape:
            // Close dropdown and clear selection
            hidePopup();
            if (m_lineEdit) {
                m_lineEdit->deselect();
            }
            event->accept();
            return;
            
        case Qt::Key_Return:
        case Qt::Key_Enter:
            if (m_isPopupVisible) {
                // Dropdown is open: close it, emit selection, and advance focus
#ifdef DEBUG_COMBOBOX
                qDebug() << "[CustomScripComboBox] Enter pressed with dropdown OPEN - closing and advancing focus";
#endif
                hidePopup();
                if (m_lineEdit && !m_lineEdit->text().isEmpty()) {
                    emit itemSelected(m_lineEdit->text());
                }
                
                // Advance focus to next widget
                QWidget *nextWidget = nextInFocusChain();
                if (nextWidget) {
                    nextWidget->setFocus();
                }
                
                event->accept();
                return;
            } else {
                // Dropdown is closed: emit signal for parent to trigger action (e.g., Add button)
#ifdef DEBUG_COMBOBOX
                qDebug() << "[CustomScripComboBox] Enter pressed with dropdown CLOSED - emitting enterPressedWhenClosed signal";
#endif
                emit enterPressedWhenClosed();
                event->accept();
                return;
            }
            break;
            
        case Qt::Key_Down:
        case Qt::Key_Up:
            // Show dropdown if not visible
            if (!m_isPopupVisible && m_lineEdit) {
                QString text = m_lineEdit->text();
                if (text.length() >= m_minCharsForDropdown) {
                    showPopup();
                }
            }
            break;
            
        default:
            break;
    }
    
    QComboBox::keyPressEvent(event);
}

void CustomScripComboBox::focusInEvent(QFocusEvent *event)
{
    QComboBox::focusInEvent(event);
    
    // Auto-select text on focus for easy editing
    QTimer::singleShot(0, this, [this]() {
        if (m_lineEdit && !m_lineEdit->text().isEmpty()) {
            m_lineEdit->selectAll();
        }
    });
}

void CustomScripComboBox::showPopup()
{
    COMBO_DEBUG("showPopup called");
    m_isPopupVisible = true;
    QComboBox::showPopup();
}

void CustomScripComboBox::hidePopup()
{
    COMBO_DEBUG("hidePopup called");
    m_isPopupVisible = false;
    QComboBox::hidePopup();
}

void CustomScripComboBox::onTextEdited(const QString &text)
{
    COMBO_DEBUG("onTextEdited:" << text << "length:" << text.length());
    emit textChanged(text);
    
    // Open dropdown if not already open
    if (!m_isPopupVisible && text.length() >= m_minCharsForDropdown) {
        showPopup();
    }
    
    // Apply filtering - either instant or debounced
    if (m_instantFilter) {
        // Instant filtering - no delay, immediate response
        applyFiltering(text);
    } else if (m_filterDebounceMs > 0) {
        // Debounced filtering - wait for user to stop typing
        COMBO_DEBUG("Starting debounce timer:" << m_filterDebounceMs << "ms");
        m_filterTimer->start(m_filterDebounceMs);
    } else {
        // No debounce, apply immediately
        applyFiltering(text);
    }
}

void CustomScripComboBox::onFilterTimerTimeout()
{
    if (m_lineEdit) {
        applyFiltering(m_lineEdit->text());
    }
}

void CustomScripComboBox::onItemActivated(int index)
{
    Q_UNUSED(index)
    
    if (m_lineEdit) {
        QString selectedText = m_lineEdit->text();
        if (!selectedText.isEmpty()) {
            emit itemSelected(selectedText);
            
            // Select all text for easy next input
            QTimer::singleShot(0, this, &CustomScripComboBox::selectAllText);
        }
    }
}

void CustomScripComboBox::applyFiltering(const QString &filterText)
{
    // Skip if same as last filter (optimization)
    if (filterText == m_lastFilterText) {
        COMBO_DEBUG("applyFiltering: skipped (same as last)");
        return;
    }
    
    COMBO_DEBUG("applyFiltering:" << filterText << "from" << m_allItems.count() << "items");
    m_lastFilterText = filterText;
    
    // Update delegate with current filter for highlighting
    if (m_highlightDelegate) {
        HighlightDelegate *delegate = static_cast<HighlightDelegate*>(m_highlightDelegate);
        if (delegate) {
            delegate->setFilter(filterText);
        }
    }
    
    // Build filtered list
    QStringList filteredItems;
    
    if (filterText.isEmpty()) {
        // Empty filter = show all items
        filteredItems = m_allItems;
    } else {
        // Simple case-insensitive substring matching
        for (const QString &item : m_allItems) {
            if (item.contains(filterText, Qt::CaseInsensitive)) {
                filteredItems.append(item);
            }
        }
    }
    
    // Update model with filtered items
    m_sourceModel->clear();
    for (const QString &item : filteredItems) {
        m_sourceModel->appendRow(new QStandardItem(item));
    }
    
    COMBO_DEBUG("Filtered results:" << filteredItems.count() << "items");
    
    // Refresh view to show highlighting
    if (m_listView) {
        m_listView->viewport()->update();
    }
}

void CustomScripComboBox::sortItems()
{
    if (m_sortMode == NoSort) {
        return;
    }
    
    if (m_sortMode == AlphabeticalSort) {
        // Sort alphabetically
        std::sort(m_allItems.begin(), m_allItems.end(), 
                  [](const QString &a, const QString &b) {
            return a.compare(b, Qt::CaseInsensitive) < 0;
        });
    } else if (m_sortMode == ChronologicalSort) {
        // Sort by date
        std::sort(m_allItems.begin(), m_allItems.end(),
                  [this](const QString &a, const QString &b) {
            QDateTime dateA = parseDate(a);
            QDateTime dateB = parseDate(b);
            if (dateA.isValid() && dateB.isValid()) {
                return dateA < dateB;
            }
            // Fallback to string comparison
            return a < b;
        });
    } else if (m_sortMode == NumericSort) {
        // Sort numerically (for strike prices, integers, floats)
        std::sort(m_allItems.begin(), m_allItems.end(),
                  [](const QString &a, const QString &b) {
            bool okA, okB;
            double numA = a.toDouble(&okA);
            double numB = b.toDouble(&okB);
            
            // If both are valid numbers, compare numerically
            if (okA && okB) {
                return numA < numB;
            }
            
            // If only one is a number, number comes first
            if (okA) return true;
            if (okB) return false;
            
            // If neither is a number, compare as strings
            return a < b;
        });
    }
    
    // Rebuild model with sorted items
    m_sourceModel->clear();
    for (const QString &item : m_allItems) {
        m_sourceModel->appendRow(new QStandardItem(item));
    }
}

QDateTime CustomScripComboBox::parseDate(const QString &dateStr) const
{
    // Try common date formats used in trading
    QStringList formats = {
        "dd-MMM-yyyy",  // 26-Dec-2024
        "dd-MM-yyyy",   // 26-12-2024
        "yyyy-MM-dd",   // 2024-12-26
        "dd/MM/yyyy",   // 26/12/2024
        "MMM-yyyy",     // Dec-2024
        "MMMMyyyy",     // DEC2024
    };
    
    for (const QString &format : formats) {
        QDateTime dt = QDateTime::fromString(dateStr, format);
        if (dt.isValid()) {
            return dt;
        }
    }
    
    return QDateTime();
}

// Include moc for HighlightDelegate
#include "CustomScripComboBox.moc"


